extends c

##
## Preprocessor
# #include <...>
snippet incc
	#include <${1:iostream}>
snippet binc
	#include <boost/${1:shared_ptr}.hpp>
##
## STL Collections
# std::array
snippet array
	array<${1:T}, ${2:N}> ${3};
# std::vector
snippet vector
	vector<${1:T}> ${2};
# std::deque
snippet deque
	std::deque<${1:T}> ${2};
# std::forward_list
snippet flist
	std::forward_list<${1:T}> ${2};
# std::list
snippet list
	std::list<${1:T}> ${2};
# std::set
snippet set
	std::set<${1:T}> ${2};
# std::map
snippet map
	map<${1:Key}, ${2:T}> ${3};
# std::multiset
snippet mset
	std::multiset<${1:T}> ${2};
# std::multimap
snippet mmap
	std::multimap<${1:Key}, ${2:T}> ${3};
# std::unordered_set
snippet uset
	std::unordered_set<${1:T}> ${2};
# std::unordered_map
snippet umap
	std::unordered_map<${1:Key}, ${2:T}> ${3};
# std::unordered_multiset
snippet umset
	std::unordered_multiset<${1:T}> ${2};
# std::unordered_multimap
snippet ummap
	std::unordered_multimap<${1:Key}, ${2:T}> ${3};
# std::stack
snippet stack
	std::stack<${1:T}> ${2};
# std::queue
snippet queue
	std::queue<${1:T}> ${2};
# std::priority_queue
snippet pqueue
	std::priority_queue<${1:T}> ${2};
##
## STL smart pointers
# std::shared_ptr
snippet msp
	std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});
snippet amsp
	auto ${1} = std::make_shared<${2:T}>(${3});
# std::unique_ptr
snippet mup
	std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});
snippet amup
	auto ${1} = std::make_unique<${2:T}>(${3});
##
## Access Modifiers
# private
snippet pri
	private
# protected
snippet pro
	protected
# public
snippet pub
	public
# friend
snippet fr
	friend
# mutable
snippet mu
	mutable
##
## Class
# class
snippet cl
	class ${1:`vim_snippets#Filename('$1', 'name')`} {
		public:
			$1(${2});
			virtual ~$1();

		protected:
			m_${5}; 
	};
# member function implementation
snippet mfun
	${4:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3}) {
		${0}
	}
# member function implementation without parameters
snippet dmfun0
	/*! \brief ${4:Brief function description here}
	 *
	 *  ${5:Detailed description}
	 *
	 * \return ${6:Return parameter description}
	 */
	${3:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}() {
		${0}
	}
# member function implementation with one parameter
snippet dmfun1
	/*! \brief ${6:Brief function description here}
	 *
	 *  ${7:Detailed description}
	 *
	 * \param $4 ${8:Parameter description}
	 * \return ${9:Return parameter description}
	 */
	${5:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter}) {
		${0}
	}
# member function implementation with two parameter
snippet dmfun2
	/*! \brief ${8:Brief function description here}
	 *
	 *  ${9:Detailed description}
	 *
	 * \param $4 ${10:Parameter description}
	 * \param $6 ${11:Parameter description}
	 * \return ${12:Return parameter description}
	 */
	${7:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter},${5:Type} ${6:Parameter}) {
		${0}
	}
# namespace
snippet ns
	namespace ${1:`vim_snippets#Filename('', 'my')`} {
		${0}
	} /* namespace $1 */
snippet ans
	namespace {
		${0}
	}
##
## Input/Output
# std::cout
snippet cout
	cout << ${1} << endl;
# std::cin
snippet cin
	cin >> ${1};
##
## Casts
# static
snippet sca
	static_cast<${1:unsigned}>(${2:expr})${3}
# dynamic
snippet dca
	dynamic_cast<${1:unsigned}>(${2:expr})${3}
# reinterpret
snippet rca
	reinterpret_cast<${1:unsigned}>(${2:expr})${3}
# const
snippet cca
	const_cast<${1:unsigned}>(${2:expr})${3}
## Iteration
# for i
snippet fori
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4}
	}

# foreach
snippet fore
	for (${1:auto} ${2:i} : ${3:container}) {
		${4}
	}
# iterator
snippet iter
	for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
		${6}
	}

# auto iterator
snippet itera
	for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
		${3:std::cout << *$1 << std::endl;}
	}
##
## Lambdas
# lamda (one line)
snippet ld
	[${1}](${2}){${3}};
# lambda (multi-line)
snippet lld
	[${1}](${2}){
		${3}
	};
# snippets exception
snippet try
	try {

	}catch(${1}) {

	}
snippet af auto function
	auto ${1:name}(${2}) -> ${3:void}
	{
		${0}

	};

#template
snippet ray
	#include<bits/stdc++.h>
	using namespace std;
	#define endl '\n'
	#define deb(x) cout << #x << " = " << x << endl;
	typedef long long ll;
	typedef double dd;
	const int MOD = 1e9 + 7;

	void solve(){
		${0}
	}

	int main(){
		ios::sync_with_stdio(false);
		cin.tie(nullptr);
		cout.tie(nullptr);
		int t = 1, tt = 0;
		${1}cin >> t;
		while(t--){
			//tt++;
			//cout << "Case #" << t << ": ";
			solve();
		}
		return 0;
	}

#Vector Debugger
snippet VBUG "description"
	template<typename T>
	string to_string(vector<T> v) {
	  string res;
	  for(auto &i : v)
	    res += char('0'+i), res += ' ';
	  return res;
	}
	 
	template<class A> void vbug(A x) {
	  cout << to_string(x) << endl;
	}

#Direction
snippet Dratio "description"
	int dx[]={1, 0, -1, 0};int dy[]={0, 1, 0, -1}; //4 Direction
	int dx[]={1, 1, 0, -1, -1, -1, 0, 1};int dy[]={0, 1, 1, 1, 0, -1, -1, -1};//8 direction
	int dx[]={2, 1, -1, -2, -2, -1, 1, 2};int dy[]={1, 2, 2, 1, -1, -2, -2, -1};//Knight Direction
	int dx[]={2, 1, -1, -2, -1, 1};int dy[]={0, 1, 1, 0, -1, -1}; //Hexagonal Direction


#PBDS
snippet PBDS
	#include <ext/pb_ds/assoc_container.hpp> // Common file 
	#include <ext/pb_ds/tree_policy.hpp> 
	using namespace __gnu_pbds; 
	typedef tree<int, null_type, less<int>, rb_tree_tag, 
							 tree_order_statistics_node_update> 
			new_data_set; 

#Power
snippet Power
	ll Power(ll x, ll n) {
	  ll ans = 1;
	  while (n != 0) {
	    if (n & 1) ans = ans * x;
	    x = 1LL * x * x;
	    n >>= 1;
	  }
	  return ans;
	}

#Power mod m
snippet mpow
	ll mpow(ll x, ll n) {
	  ll ans = 1;
	  while (n != 0) {
	    if (n & 1) ans = ans * x % MOD;
	    x = 1LL * x * x % MOD;
	    n >>= 1;
	  }
	  return ans;
	}

#DSU weight
snippet DSUw
	struct DSU {
		vector<int> data;
		DSU(int n) {data.assign(n, -1);}
		bool unionSet(int x, int y) {
			x = root(x); y = root(y);
			if(x != y) {
				if (data[y] < data[x]) std::swap(x, y);
				data[x] += data[y]; data[y] = x;
			}
			return x != y;
		}
		bool findSet(int x, int y) {return root(x) == root(y);}
		int root(int x) {return data[x] < 0 ? x : data[x] = root(data[x]);}
		int size(int x) {return -data[root(x)]; }
	};


#DSU rank
snippet DSUr
	template<typename T>
	class dsu {
	  public:
	    vector<T>p;
	    vector<T>rank;
	    ll n;

	    dsu(ll _n) : n(_n) {
	      p.resize(n);
	      rank.resize(n);
	      iota(p.begin(), p.end(), 0);
	      fill(rank.begin(), rank.end(), 1);
	    }
	    inline T root(T x) {
	      return (x == p[x] ? x : (p[x] = root(p[x])));
	    }
	    
	    inline bool same(int u, int v) {
	        return(root(u) == root(v));
	    }

	    inline void unite(T x, T y) {
	      x = root(x);
	      y = root(y);
	      if(x != y) {
	        if(rank[y] < rank[x]) 
	          swap(x, y);
	        p[x] = y;
	        if(rank[x] == rank[y])
	          rank[y]++;
	      }
	    }
	};

#Fenwik Tree
snippet fenwik
	template<typename T>
	class BIT {
	  int n;
	  vector<T> bit;
	public:
	  BIT(int N) {
	    bit.assign(N + 1 , 0);
	    n = N;
	  }
	  void update(int idx , T val) {
	    idx++;
	    while(idx <= n) {
	      bit[idx] += val;
	      idx += (idx & -idx);
	    }
	  }
	  int sum(int idx) {
	    idx++;
	    T res = 0;
	    while(idx > 0) {
	      res += bit[idx];
	      idx -= (idx & -idx);
	    }
	    return res;
	  }

	};

#Combination
snippet Comb
	vector<ll> fac(1000001); //n!(mod M)
	vector<ll> ifac(1000001); //k!^{M-2} (mod M)
	ll mpow2(ll x, ll n) {
	  ll ans = 1;
	  while (n != 0) {
	    if (n & 1) ans = ans * x % MOD;
	    x = 1LL * x * x % MOD;
	    n >>= 1;
	  }
	  return ans;
	}

	ll comb(ll n, ll k){
	    return 1LL * fac[n] * ifac[k] % MOD * ifac[n - k] % MOD;
	}

	void setcomb() {
	  fac.resize(MAXN);
	  ifac.resize(MAXN);
	  fac[0] = 1LL;
	  ifac[0] = 1LL;
	  for (ll i = 1; i < MAXN; i++) {
	    fac[i] = (fac[i-1] * i) % MOD; 
	  }
	  ifac[siz-1] = mpow2(fac[MAXN-1], MOD - 2LL);
	  for (ll i = siz-2; i >= 0; i--) {
	    ifac[i] = 1LL * ifac[i+1] * (i+1) % MOD;
	  }
	}

#Prime factorization
snippet primefactor 
	void sieve(){ 
		iota(spf.begin(), spf.end() , 1);
		for (int i = 4 ; i < MAXN ;  i += 2) 
			spf[i] = 2; 
			
		for (int i = 3 ; i * i < MAXN ; i++) { 
			if (spf[i] == i) { 
				for (int j = i * i; j < MAXN ;  j += i) 
					if (spf[j] == j) 
						spf[j] = i; 
			} 
		} 
	} 
	vector<int> getF(int x){ 
		vector<int> factors; 
		while (x != 1) { 
			x = x / spf[x]; 
			factors.push_back(spf[x]); 
		} 
		return factors; 
	} 

#Fastscan
snippet fastscan
	template <typename T>
	void fastscan(T &x){
		bool neg = false;
		register int c;
		x = 0;
		c = getchar();
		if(c == '-'){
			neg = true;
			c=getchar();
		}
		for(;(c > 47 && c < 58); c = getchar())
			x = (x << 1) + (x << 3) +c -48;
		if(neg)
			x *= -1;
	}

#Extended GCD
snippet extendedgcd
	ll extGCD(ll a, ll b, ll &x, ll &y) {
		if (b == 0) {
			x = 1;
			y = 0;
			return a;
		}
		ll d = extGCD(b, a%b, y, x);
		y -= a / b * x;
		return d;
	}

#Mod operation
snippet modoperation 	
	ll MODadd(ll x, ll y){return (x % MOD + y % MOD) % MOD;}
	ll MODmul(ll x, ll y){return (x % MOD * y % MOD) % MOD;}
	ll MODsub(ll x, ll y){return (x % MOD - y % MOD + MOD) % MOD;}
	ll MODdiv(ll x, ll y){return MODmul(x, mpow(y, MOD-2));}

#Seive
snippet seive
	vector<int>is_prime;
	void seive(int n) {
		is_prime.assign(n+1, true);
		is_prime[0] = is_prime[1] = false;
		for (int i = 2; i * i <= n; i++) {
		  if (is_prime[i]) {
		    for (int j = i * i; j <= n; j += i)
	          is_prime[j] = false;
		  }
		}
	}

#Dijkstra
snippet dijkstra
	const int INF = 1e9;
	typedef pair<int, int> pri;
	vector<vector<pri>>adj;
	vector<int>dis;

	void dijk(int s) {
	  priority_queue<pri, vector<pri>, greater<pri>>q;
	  dis[s] = 0;
	  q.push({0, s});
	  while(!q.empty()) {
	    auto x = q.top();
	    q.pop();
	    int u = x.second;
	    if(x.first == INF) continue;
	    for(auto i : adj[u]) {
	      int v = i.first;
	      int c = i.second;
	      if(dis[v] > dis[u]+c) {
	        dis[v] = dis[u]+c;
	        q.push({dis[v], v});
	      }
	    }
	  }
	}
#DEBUG
snippet DEBUG
	template <typename A, typename B>
	string to_string(pair<A, B> p);
	 
	template <typename A, typename B, typename C>
	string to_string(tuple<A, B, C> p);
	 
	template <typename A, typename B, typename C, typename D>
	string to_string(tuple<A, B, C, D> p);
	 
	string to_string(const string& s) {
		return '"' + s + '"';
	}
	 
	string to_string(const char* s) {
		return to_string((string) s);
	}
	 
	string to_string(bool b) {
		return (b ? "true" : "false");
	}
	 
	string to_string(vector<bool> v) {
		bool first = true;
		string res = "{";
		for (int i = 0; i < static_cast<int>(v.size()); i++) {
			if (!first) {
				res += ", ";
			}
			first = false;
			res += to_string(v[i]);
		}
		res += "}";
		return res;
	}
	 
	template <size_t N>
	string to_string(bitset<N> v) {
		string res = "";
		for (size_t i = 0; i < N; i++) {
			res += static_cast<char>('0' + v[i]);
		}
		return res;
	}
	 
	template <typename A>
	string to_string(A v) {
		bool first = true;
		string res = "{";
		for (const auto &x : v) {
			if (!first) {
				res += ", ";
			}
			first = false;
			res += to_string(x);
		}
		res += "}";
		return res;
	}
	 
	template <typename A, typename B>
	string to_string(pair<A, B> p) {
		return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";
	}
	 
	template <typename A, typename B, typename C>
	string to_string(tuple<A, B, C> p) {
		return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";
	}
	 
	template <typename A, typename B, typename C, typename D>
	string to_string(tuple<A, B, C, D> p) {
		return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";
	}
	 
	void debug_out() { cerr << endl; }
	 
	template <typename Head, typename... Tail>
	void debug_out(Head H, Tail... T) {
		cerr << " " << to_string(H);
		debug_out(T...);
	}
	 
	#ifdef RAY
	#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
	#else
	#define debug(...) 42
	#endif

#Centroid
snippet Centroids
	vector<int> Centroid(const vector<vector<int>> &g) {
		int n = g.size();
		vector<int> centroid;
		vector<int> sz(n);
		function<void (int, int)> dfs = [&](int u, int prev) {
			sz[u] = 1;
			bool is_centroid = true;
			for (auto v : g[u]) if (v != prev) {
				dfs(v, u);
				sz[u] += sz[v];
				if (sz[v] > n / 2) is_centroid = false;
			}
			if (n - sz[u] > n / 2) is_centroid = false;
			if (is_centroid) centroid.push_back(u);
		};
		dfs(0, -1);
		return centroid;
	}
